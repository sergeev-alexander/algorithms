package sergeev.alexander.diverse_tasks;

import java.util.Arrays;
import java.util.Scanner;

public class PeterProgrammerField {
    /*
    После очередного завершённого проекта программист Пётр решил переехать в деревню и заняться сельским хозяйством.
    Мелочиться он не стал, поэтому помимо домика в деревне сразу приобрёл несколько идущих подряд параллельных
    участков поля, расположенных вдоль прямой дороги. Участки были разделены заборами, при этом все заборы начинались
    от той самой дороги, но заканчивались на разном удалении от неё не доходя до противоположной границы участка.
    Петру нужно объединить эти участки. Но так как Пётр перфекционист, он непременно хочет, чтобы получившийся
    объединённый участок:
    1. был прямоугольным;
    2. был ограничен дорогой и двумя уже имеющимися заборами (забор необязательно использовать целиком, а вот удлинять
    забор нельзя);
    3. имел наибольшую возможную площадь.
    Как и положено разработчику Пётр получает 300к/наносек, поэтому его совсем не беспокоит тот факт, что часть
    территории окажется неиспользованной.
    Пётр хочет отдохнуть, поэтому он попросил вас помочь с нахождением площади такого участка.
    Помогите Петру и найдите два забора, которые вместе с дорогой образуют максимальный по площади прямоугольный
    участок, и выведите эту площадь.
    Ширина всех участков одинакова и равна 1.
    Входные данные (поступают в стандартный поток ввода)
    На вход вашей программе подаётся одна строка, содержащая массив целых чисел length,
    где length[i] - длина i-ого забора. Иными словами i-ый элемент массива задаёт забор в виде отрезка
    от (i, 0) до (i, length[i]), где 0 - это дорога.
    Причём 0≤length[i]≤10 000, а количество заборов n удовлетворяет условию 2≤n≤100 000.
    Все входные данные наших тестов всегда соблюдают указанные параметры, дополнительные проверки не требуются.
    Выходные данные (ожидаются в стандартном потоке вывода)
    Одно целое число, максимальная площадь образованного участка.
    Пример 1
    Ввод:
    2 4 3 2 1 4 1
    Вывод:
    16
    В первом примере участок наибольшей площади образуется между двумя заборами длины 4.
    Пример 2
    Ввод:
    1 2
    Вывод:
    1
    В данном примере второй забор используется не на всю длину, т.к. нас интересуют только прямоугольные участки.
     */

    public static void main(String[] args) {

        int[] arr = Arrays.stream(new Scanner(System.in).nextLine().split(" "))
                .parallel()
                .mapToInt(Integer::parseInt)
                .toArray();

        int maxSquare = 0;

        long start = System.nanoTime();

        int right = arr.length - 1;
        int left = 0;
        while (left < right) {
            int minLength = arr[left] <= arr[right] ? arr[left] : arr[right];
            int currentSquare = minLength * (right - left);
            if (currentSquare > maxSquare) {
                maxSquare = currentSquare;
            } else {
                if (arr[left] < arr[right]) {
                    left++;
                } else if (arr[left] > arr[right]) {
                    right--;
                } else {
                    left++;
                    right--;
                }
            }
        }

//    public static int findMaxSquare(int[] arr, int left, int right){};
//        for (int i = 0; i < arr.length; i++) {
//            for (int j = i + 1; j < arr.length; j++) {
//                int currentSquare;
//                if (arr[i] <= arr[j]) {
//                    currentSquare = arr[i] * (j - i);
//                } else {
//                    currentSquare = (arr[i] - (arr[i] - arr[j])) * (j - i);
//                }
//                if (currentSquare > maxSquare) {
//                    maxSquare = currentSquare;
//                }
//            }
//        }

        long end = System.nanoTime();

        System.out.println(maxSquare);

        System.out.println("Time - " + (end - start));
    }
}
